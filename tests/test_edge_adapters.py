from __future__ import annotations

import json
import unittest

import json
import unittest
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent
CONTRACT_FILE = REPO_ROOT / "tests/edge_matrix/contracts.json"
EXPECTED_DIR = REPO_ROOT / "tests/edge_matrix/expected"

EDGE_DEFAULTS = {
    "router_entrypoint": "web",
    "scheme": "http",
    "path_prefix": "/",
    "tls": False,
    "tls_certresolver": None,
}
EDGE_REQUIRED_KEYS = ["APP_FQDN", "APP_PORT", "APP_BACKEND_IP"]
OPNSENSE_BIND_ADDRESSES = [
    {"address": "0.0.0.0", "port": 80, "tls": False},
    {"address": "0.0.0.0", "port": 443, "tls": True},
]
PFSENSE_BIND_ADDRESSES = [
    {"address": "0.0.0.0", "port": 80, "tls": False},
    {"address": "0.0.0.0", "port": 443, "tls": True},
]


def sanitize_identifier(value: str) -> str:
    return "".join(ch if ch.isalnum() or ch == "_" else "_" for ch in value)


def load_edge_defaults() -> tuple[dict, list[str]]:
    return EDGE_DEFAULTS.copy(), list(EDGE_REQUIRED_KEYS)


def build_backends(contracts: list[dict]) -> list[dict]:
    defaults, required_keys = load_edge_defaults()
    backends: list[dict] = []

    for contract in contracts:
        exports = contract.get("exports", {})
        missing = [key for key in required_keys if not exports.get(key)]
        if missing:
            raise AssertionError(
                f"Contract {contract.get('service_id', exports.get('APP_FQDN', '<unnamed>'))} missing exports {missing}"
            )

        service_id = contract.get("service_id", exports["APP_FQDN"])
        router_name = contract.get("router_name", f"{service_id}-router")
        tls = bool(contract.get("tls", defaults.get("tls", False)))
        tls_certresolver = contract.get(
            "tls_certresolver", defaults.get("tls_certresolver")
        )
        if not tls and tls_certresolver:
            raise AssertionError(
                f"Contract {service_id} defined tls_certresolver without enabling tls"
            )

        backend = {
            "service_id": service_id,
            "router_name": router_name,
            "router_entrypoint": contract.get(
                "router_entrypoint", defaults.get("router_entrypoint")
            ),
            "tls": tls,
            "tls_certresolver": tls_certresolver,
            "scheme": contract.get("scheme", defaults.get("scheme")),
            "path_prefix": contract.get("path_prefix", defaults.get("path_prefix")),
            "middlewares": contract.get("middlewares", []),
            "pass_host_header": bool(contract.get("pass_host_header", True)),
            "preserve_host": bool(contract.get("preserve_host", False)),
            "exports": exports,
            "service_labels": contract.get("service_labels", {}),
        }
        backends.append(backend)
    return backends


def render_traefik(backends: list[dict]) -> str:
    lines: list[str] = [
        "# Autogenerated by edge_proxy_traefik role. Do not edit manually.",
        "http:",
        "  routers:",
    ]

    websocket_backends: list[dict] = []

    for backend in backends:
        lines.append(f"    {backend['router_name']}:")
        lines.append("      entryPoints:")
        lines.append(f"        - {backend['router_entrypoint']}")
        rule = f"Host(`{backend['exports']['APP_FQDN']}`)"
        if backend["path_prefix"] != "/":
            rule += f" && PathPrefix(`{backend['path_prefix']}`)"
        lines.append(f'      rule: "{rule}"')
        lines.append(f"      service: {backend['service_id']}")

        router_middlewares = list(backend.get("middlewares", []))
        if backend.get("websocket"):
            router_middlewares.append(f"{backend['service_id']}-websocket")
            websocket_backends.append(backend)

        if backend["tls"]:
            lines.append("      tls:")
            if backend.get("tls_certresolver"):
                lines.append(f"        certResolver: {backend['tls_certresolver']}")

        if router_middlewares:
            lines.append("      middlewares:")
            for middleware in router_middlewares:
                lines.append(f"        - {middleware}")

    if websocket_backends:
        lines.append("  middlewares:")
        for backend in websocket_backends:
            lines.append(f"    {backend['service_id']}-websocket:")
            lines.append("      headers:")
            lines.append("        customRequestHeaders:")
            lines.append('          Connection: "Upgrade"')
            lines.append("        customResponseHeaders:")
            lines.append('          Connection: "Upgrade"')

    lines.append("  services:")
    for backend in backends:
        lines.append(f"    {backend['service_id']}:")
        lines.append("      loadBalancer:")
        lines.append(
            f"        passHostHeader: {str(backend['pass_host_header']).lower()}"
        )
        lines.append("        servers:")
        upstream = f"{backend['scheme']}://{backend['exports']['APP_BACKEND_IP']}:{backend['exports']['APP_PORT']}"
        lines.append(f'          - url: "{upstream}"')

    return "\n".join(lines) + "\n"


def render_haproxy(backends: list[dict]) -> str:
    lines: list[str] = [
        "# Autogenerated by edge_proxy_haproxy role. Do not edit manually.",
        "",
        "global",
        "  maxconn 2048",
        "",
        "defaults",
        "  mode http",
        "  timeout connect 5s",
        "  timeout client  50s",
        "  timeout server  50s",
        "  option httplog",
        "  option dontlognull",
        "  option http-server-close",
        "  option forwardfor",
        "",
    ]

    lines.append("frontend http_ingress")
    lines.append("  bind *:80")
    lines.append("  mode http")
    for backend in backends:
        acl_id = sanitize_identifier(backend["service_id"])
        lines.append(
            f"  acl host_{acl_id} hdr(host) -i {backend['exports']['APP_FQDN']}"
        )
        if backend["path_prefix"] != "/":
            lines.append(f"  acl path_{acl_id} path_beg {backend['path_prefix']}")
            lines.append(
                f"  use_backend {backend['service_id']} if host_{acl_id} path_{acl_id}"
            )
        else:
            lines.append(f"  use_backend {backend['service_id']} if host_{acl_id}")
    lines.append("")

    lines.append("frontend https_ingress")
    lines.append("  bind *:443 ssl crt /usr/local/etc/haproxy/tls.pem")
    lines.append("  mode http")
    for backend in backends:
        acl_id = sanitize_identifier(backend["service_id"])
        lines.append(
            f"  acl host_tls_{acl_id} hdr(host) -i {backend['exports']['APP_FQDN']}"
        )
        if backend["path_prefix"] != "/":
            lines.append(f"  acl path_tls_{acl_id} path_beg {backend['path_prefix']}")
            lines.append(
                f"  use_backend {backend['service_id']} if host_tls_{acl_id} path_tls_{acl_id}"
            )
        else:
            lines.append(f"  use_backend {backend['service_id']} if host_tls_{acl_id}")
    lines.append("")

    for backend in backends:
        lines.append(f"backend {backend['service_id']}")
        lines.append("  mode http")
        lines.append("  option httpchk")
        health_path = backend["path_prefix"] if backend["path_prefix"] != "/" else "/"
        lines.append(f"  http-check send meth GET uri {health_path}")
        upstream = (
            f"{backend['exports']['APP_BACKEND_IP']}:{backend['exports']['APP_PORT']}"
        )
        lines.append(f"  server {backend['service_id']} {upstream} check")
        if backend.get("websocket"):
            lines.append("  acl upgrade_websocket hdr(Upgrade) -i WebSocket")
            lines.append(
                '  http-request set-header Connection "upgrade" if upgrade_websocket'
            )
            lines.append(
                '  http-response set-header Connection "upgrade" if { res.hdr(Upgrade) -i WebSocket }'
            )
        lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def build_opnsense_payload(backends: list[dict]) -> dict:
    payload_backends = []
    payload_frontends = []

    for backend in backends:
        payload_backends.append(
            {
                "name": backend["service_id"],
                "mode": "http",
                "retries": 3,
                "httpcheck_method": "GET",
                "httpcheck_path": (
                    backend["path_prefix"] if backend["path_prefix"] != "/" else "/"
                ),
                "servers": [
                    {
                        "name": f"{backend['service_id']}-primary",
                        "address": backend["exports"]["APP_BACKEND_IP"],
                        "port": backend["exports"]["APP_PORT"],
                        "ssl": "true" if backend["scheme"] == "https" else "false",
                        "verify": "false",
                    }
                ],
            }
        )

        rules = [{"type": "Host", "value": backend["exports"]["APP_FQDN"]}]
        if backend["path_prefix"] != "/":
            rules.append({"type": "PathPrefix", "value": backend["path_prefix"]})

        binds = [
            {
                "address": str(bind["address"]),
                "port": str(bind["port"]),
                "ssl": "true" if bind.get("tls") else "false",
            }
            for bind in OPNSENSE_BIND_ADDRESSES
        ]

        payload_frontends.append(
            {
                "name": backend["router_name"],
                "mode": "http",
                "default_backend": backend["service_id"],
                "rules": rules,
                "binds": binds,
                "tls_enabled": "true" if backend["tls"] else "false",
                "tls_certificate": "tls-cert-haproxy" if backend["tls"] else "",
            }
        )

    return {
        "url": "https://edge-opnsense.local:443/api/haproxy/service/bulkImport",
        "method": "POST",
        "body_format": "json",
        "body": {
            "backends": payload_backends,
            "frontends": payload_frontends,
        },
    }


def build_pfsense_payload(backends: list[dict]) -> dict:
    payload_backends = []
    payload_frontends = []

    for backend in backends:
        payload_backends.append(
            {
                "name": backend["service_id"],
                "balance": "roundrobin",
                "health_check_enabled": True,
                "health_check_method": "GET",
                "health_check_path": (
                    backend["path_prefix"] if backend["path_prefix"] != "/" else "/"
                ),
                "servers": [
                    {
                        "name": f"{backend['service_id']}-primary",
                        "address": backend["exports"]["APP_BACKEND_IP"],
                        "port": backend["exports"]["APP_PORT"],
                        "ssl": backend["scheme"] == "https",
                    }
                ],
            }
        )

        rules = [{"type": "host", "value": backend["exports"]["APP_FQDN"]}]
        if backend["path_prefix"] != "/":
            rules.append({"type": "path_beg", "value": backend["path_prefix"]})

        payload_frontends.append(
            {
                "name": backend["router_name"],
                "listen_addresses": [
                    {
                        "address": str(bind["address"]),
                        "port": str(bind["port"]),
                        "ssl": bind.get("tls", False),
                    }
                    for bind in PFSENSE_BIND_ADDRESSES
                ],
                "rules": rules,
                "default_backend": backend["service_id"],
                "tls_enabled": backend["tls"],
                "tls_certificate_ref": "tls-cert-ref" if backend["tls"] else "",
            }
        )

    return {
        "url": "https://edge-pfsense.local:443/api/v1/services/haproxy/config",
        "method": "POST",
        "body_format": "json",
        "headers": {"Authorization": "haproxy-subsystem-token"},
        "body": {
            "frontends": payload_frontends,
            "backends": payload_backends,
        },
    }


def build_pfsense_squid_payload(backends: list[dict]) -> dict:
    payload_peers = []
    payload_mappings = []

    for backend in backends:
        payload_peers.append(
            {
                "name": backend["service_id"],
                "host": backend["exports"]["APP_BACKEND_IP"],
                "port": backend["exports"]["APP_PORT"],
                "originserver": True,
                "ssl": backend["scheme"] == "https",
            }
        )

        payload_mappings.append(
            {
                "servername": backend["exports"]["APP_FQDN"],
                "path": (
                    backend["path_prefix"] if backend["path_prefix"] != "/" else "/"
                ),
                "peer": backend["service_id"],
                "tls": backend["tls"],
            }
        )

    return {
        "url": "https://edge-pfsense.local:443/api/v1/services/squid/reverse_proxy",
        "method": "POST",
        "body_format": "json",
        "headers": {"Authorization": "squid-subsystem-token"},
        "body": {
            "peers": payload_peers,
            "mappings": payload_mappings,
        },
    }


class EdgeAdapterMatrixTest(unittest.TestCase):
    maxDiff = None

    @classmethod
    def setUpClass(cls) -> None:
        contracts = json.loads(CONTRACT_FILE.read_text(encoding="utf-8"))[
            "edge_ingress_contracts"
        ]
        cls.backends = build_backends(contracts)

    def assert_yaml_equal(self, expected_path: Path, actual_text: str) -> None:
        expected = expected_path.read_text(encoding="utf-8").strip()
        self.assertEqual(expected, actual_text.strip())

    def assert_json_equal(self, expected_path: Path, actual_payload: dict) -> None:
        expected = json.loads(expected_path.read_text(encoding="utf-8"))
        self.assertEqual(expected, actual_payload)

    def test_traefik_golden(self) -> None:
        rendered = render_traefik(self.backends)
        self.assert_yaml_equal(EXPECTED_DIR / "traefik.ingress.yml", rendered)

    def test_haproxy_golden(self) -> None:
        rendered = render_haproxy(self.backends)
        self.assert_yaml_equal(EXPECTED_DIR / "haproxy.cfg", rendered)

    def test_opnsense_golden(self) -> None:
        payload = build_opnsense_payload(self.backends)
        self.assert_json_equal(
            EXPECTED_DIR / "opnsense_haproxy_bulkImport.json", payload
        )

    def test_pfsense_golden(self) -> None:
        payload = build_pfsense_payload(self.backends)
        self.assert_json_equal(EXPECTED_DIR / "pfsense_haproxy_config.json", payload)

    def test_pfsense_squid_golden(self) -> None:
        payload = build_pfsense_squid_payload(self.backends)
        self.assert_json_equal(
            EXPECTED_DIR / "pfsense_squid_reverse_proxy.json", payload
        )


if __name__ == "__main__":
    unittest.main()
