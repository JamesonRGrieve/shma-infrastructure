#!/usr/bin/env python3
"""Stub for ``docker compose`` commands used in CI."""

from __future__ import annotations

import json
import sys
from pathlib import Path

if __package__ in {None, ""}:
    parent = Path(__file__).resolve().parents[1]
    if str(parent) not in sys.path:
        sys.path.insert(0, str(parent))

import yaml


def _load_manifest(path: Path) -> dict:
    try:
        data = yaml.safe_load(path.read_text())
    except yaml.YAMLError as exc:
        raise SystemExit(f"docker: failed to parse compose file {path}: {exc}") from exc
    if not isinstance(data, dict):
        raise SystemExit(f"docker: compose file {path} must be a mapping")
    return data


def main(argv: list[str] | None = None) -> int:
    args = argv if argv is not None else sys.argv[1:]
    if args[:2] != ["compose", "-f"] or len(args) < 4 or args[3] != "config":
        print("docker stub supports only 'docker compose -f <file> config'")
        return 0

    manifest_path = Path(args[2])
    manifest = _load_manifest(manifest_path)
    services = manifest.get("services")
    if not isinstance(services, dict):
        raise SystemExit(
            f"docker: compose file {manifest_path} missing services section"
        )

    print(json.dumps(manifest, indent=2))
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())
